{"name":"Z'Blog","tagline":"Hello ! Welcome to my blog","body":"# 初学Adler32算法和MD5加密算法\r\n### 2014-07-13\r\n参加hadoop暑假实训，收获颇多。前五天由邵老师(和蔼的大师兄)给大家讲述了Java的基础知识及面向对象的编程思想，同时一步步重构、完善了一个单机版的bank业务程序。加强了对Java语言运用的熟练外，也体会到了一个项目由0开始、构思，到初步实现，不断运用新知识对其重构，再到加强业务逻辑处理，修复bug，这一整个过程所散发出的魅力。\r\n\r\n第六天开始，谢老师来了，风格果然独特。基本表达式、组合的方法、抽象的方法，三句话边总结了快速学习一门语言的精髓。慢慢领悟吧。然后便开始讲解今天的主题：Adler32算法和MD5加密算法。\r\n\r\n### Adler32算法（摘取自Wiki）：\r\nAn Adler-32 checksum is obtained by calculating two 16-bit checksums A and B and concatenating their bits into a 32-bit integer. A is the sum of all bytes in the stream plus one, and B is the sum of the individual values of A from each step.\r\nAt the beginning of an Adler-32 run, A is initialized to 1, B to 0. The sums are done modulo 65521 (the largest prime number smaller than 216). The bytes are stored in network order (big endian), B occupying the two most significant bytes.\r\n\r\nThe function may be expressed as\r\n\r\nA = 1 + D1 + D2 + ... + Dn (mod 65521)\r\n\r\nB = (1 + D1) + (1 + D1 + D2) + ... + (1 + D1 + D2 + ... + Dn) (mod 65521) = n×D1 + (n−1)×D2 + (n−2)×D3 + ... + Dn + n (mod 65521)\r\n\r\nAdler-32(D) = B × 65536 + A\r\n\r\nwhere D is the string of bytes for which the checksum is to be calculated, and n is the length of D.\r\n\r\n### Example：\r\nThe Adler-32 sum of the ASCII string \"Wikipedia\" would be calculated as follows:\r\n\r\n<table class=\"wikitable\" border=\"1\">\r\n<tbody>\r\n<tr>\r\n<th>Character</th>\r\n<th>ASCII code</th>\r\n<th></th>\r\n<th colspan=\"3\" align=\"center\">A</th>\r\n<th></th>\r\n<th colspan=\"3\" align=\"center\">B</th>\r\n</tr>\r\n<tr>\r\n<td colspan=\"12\" align=\"left\">\r\n(shown as base 10)\r\n</td>\r\n</tr>\r\n<tr>\r\n<td>W</td>\r\n<td style=\"text-align: right\">87</td>\r\n<td></td>\r\n<td align=\"center\" colspan=\"3\">1 + 87 = 88</td>\r\n<td></td>\r\n<td align=\"center\" colspan=\"3\">0 + 88 = 88</td>\r\n</tr>\r\n<tr>\r\n<td>i</td>\r\n<td style=\"text-align: right\">105</td>\r\n<td></td>\r\n<td align=\"center\" colspan=\"3\">88 + 105 = 193</td>\r\n<td></td>\r\n<td align=\"center\" colspan=\"3\">88 + 193 = 281</td>\r\n</tr>\r\n<tr>\r\n<td>k</td>\r\n<td style=\"text-align: right\">107</td>\r\n<td></td>\r\n<td align=\"center\" colspan=\"3\">193 + 107 = 300</td>\r\n<td></td>\r\n<td align=\"center\" colspan=\"3\">281 + 300 = 581</td>\r\n</tr>\r\n<tr>\r\n<td>i</td>\r\n<td style=\"text-align: right\">105</td>\r\n<td></td>\r\n<td align=\"center\" colspan=\"3\">300 + 105 = 405</td>\r\n<td></td>\r\n<td align=\"center\" colspan=\"3\">581 + 405 = 986</td>\r\n</tr>\r\n<tr>\r\n<td>p</td>\r\n<td style=\"text-align: right\">112</td>\r\n<td></td>\r\n<td align=\"center\" colspan=\"3\">405 + 112 = 517</td>\r\n<td></td>\r\n<td align=\"center\" colspan=\"3\">986 + 517 = 1503</td>\r\n</tr>\r\n<tr>\r\n<td>e</td>\r\n<td style=\"text-align: right\">101</td>\r\n<td></td>\r\n<td align=\"center\" colspan=\"3\">517 + 101 = 618</td>\r\n<td></td>\r\n<td align=\"center\" colspan=\"3\">1503 + 618 = 2121</td>\r\n</tr>\r\n<tr>\r\n<td>d</td>\r\n<td style=\"text-align: right\">100</td>\r\n<td></td>\r\n<td align=\"center\" colspan=\"3\">618 + 100 = 718</td>\r\n<td></td>\r\n<td align=\"center\" colspan=\"3\">2121 + 718 = 2839</td>\r\n</tr>\r\n<tr>\r\n<td>i</td>\r\n<td style=\"text-align: right\">105</td>\r\n<td></td>\r\n<td align=\"center\" colspan=\"3\">718 + 105 = 823</td>\r\n<td></td>\r\n<td align=\"center\" colspan=\"3\">2839 + 823 = 3662</td>\r\n</tr>\r\n<tr>\r\n<td>a</td>\r\n<td style=\"text-align: right\">97</td>\r\n<td></td>\r\n<td align=\"center\" colspan=\"3\">823 + 97 = 920</td>\r\n<td></td>\r\n<td align=\"center\" colspan=\"3\">3662 + 920 = 4582</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\nA = 920  =  398 hex  (base 16)\r\n\r\nB = 4582 = 11E6 hex\r\n\r\nOutput = 4,582 × 65,536 + 920 = 300286872 = 11E60398 hex\r\n\r\n### Adler32算法代码实现：\r\n```\r\npublic static int set(byte[] data){\r\n\tint mod = 65521,\r\n\t\ta = 1,\r\n\t\tb = 0;\r\n\tfor(int i = 0; i < data.length; i++){\r\n\t\ta = a + data[i];\r\n\t\tb = a + b;\r\n\t}\r\n\ta = a % mod;\r\n\tb = b % mod;\t\r\n\treturn b * 65536 + a;\r\n}\r\n\r\n//老师改进版\r\npublic static final int MOD = 65521;\r\npublic static int adler32(byte[] datas){\r\n\tint A = 1;\r\n\tint B = 0;\r\n\tfor(byte b:datas){\r\n\t\tA = A + b;\r\n\t\tB = B + A;\r\n\t}\r\n\tA = A % MOD;\r\n\tB = B % MOD;\r\n\treturn B << 16 | A;\r\n}\r\n```\r\n\r\n\r\n### MD5加密算法（还是摘取自Wiki）：\r\nMD5是输入不定长度信息，输出固定长度128-bits的算法。经过程序流程，生成四个32位数据，最后联合起来成为一个128-bits散列。基本方式为，求余、取余、调整长度、与链接变量进行循环运算。得出结果。\r\n\r\nF(X,Y,Z) = (X 与 Y) 或 (非 X 与Z)\r\n\r\nG(X,Y,Z) = (X 与 Z) 或 (Y 与 非Z)\r\n\r\nH(X,Y,Z) = X 异或 Y 异或 Z\r\n\r\nI(X,Y,Z) = Y 异或 (X 或 非Z)\r\n\r\n### MD5加密算法代码实现：\r\n```\r\npublic class MD5 {\r\n\tpublic static String getMD5(byte[] source){\r\n\t\tString s = null;\r\n\t\tchar hexDigits[] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D','E', 'F' };\r\n\t\ttry {\r\n\t\t\tjava.security.MessageDigest md = java.security.MessageDigest.getInstance(\"MD5\");\r\n\t\t\tmd.update(source);\r\n\t\t\tbyte datas[] = md.digest();\r\n\t\t\tchar str[] = new char[16 * 2];\r\n\t\t\tint k = 0;\r\n\t\t\tfor (int i = 0; i < 16; i++) { \r\n\t\t\t\tbyte b = datas[i]; // 取第 i 个字节\r\n\t\t\t\tstr[k++] = hexDigits[b >>> 4 & 0xf]; // 取字节中高 4 位的数字转换, >>> 为逻辑右移，将符号位一起右移\r\n\t\t\t\tstr[k++] = hexDigits[b & 0xf]; // 取字节中低 4 位的数字转换\r\n\t\t\t\ts = new String(str); // 换后的结果转换为字符串\r\n\t\t\t}\r\n\t\t} catch (NoSuchAlgorithmException e) {\r\n\t\t\te.printStackTrace();\r\n\t\t}\r\n\t\treturn s;\r\n\t}\r\n}\r\n```","google":"Java JavaScript JQuery HTML","note":"Don't delete this file! It's used internally to help with page regeneration."}